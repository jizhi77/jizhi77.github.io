{"pages":[{"title":"","text":"这是关于","link":"/about.html"}],"posts":[{"title":"说说 React 系列之：Context","text":"引言 Context 设计的目的是为了共享那些对于同一组件树而言是\"全局\"的数据 Context 主要应用场景在于很多不同层级的组件需要访问同样的数据 上面 组件通信方式 一文讲过，React 中组件之间传递数据的形式无非props、Context、redux 等几种，每种方式都有其应用的场景。如果： 既不想使用 redux，因为其太复杂（一堆的 action、reducer） 又被跨级多组件共享状态时传递props搞的晕头转向的情况 那么此时就可以考虑使用Context 这个特性了。 API React.createContext Context.Provider Context.Consumer Context.displayName class.contextType 使用姿势姿势一 姿势一：只创建Context对象，组件引用并读取Context的值 1、Context.js提供 Context 容器。 Context.js12import React from &quot;react&quot;;export const ThemeContext = React.createContext('red') 2、其他组件引用容器并声明contextType属性后读取Context容器的默认值。 Child.js123456789101112131415161718192021import React, { Component } from &quot;react&quot;;import SecondChild from './SecondChild'import { ThemeContext } from './res/Context'class Child extends Component { static contextType = ThemeContext render() { return ( &lt;div className=&quot;childWrap&quot;&gt; &lt;div&gt; Child 组件的主题色：&lt;span style={{ color: this.context }}&gt;{this.context}&lt;/span&gt; &lt;/div&gt; &lt;SecondChild /&gt; &lt;/div&gt; ) }}export default Child SecondChild.js1234567891011121314151617import React, { Component } from &quot;react&quot;;import { ThemeContext } from './res/Context'class SecondChild extends Component { static contextType = ThemeContext render() { return ( &lt;div className=&quot;secondChildWrap&quot;&gt; SecondChild 组件的主题色&lt;span style={{ color: this.context }}&gt;{this.context}&lt;/span&gt; &lt;/div&gt; ) }}export default SecondChild 姿势二 创建Context对象，顶级组件提供Provider并赋予新值。 1、Context.js提供 Context 容器。 Context.js12import React from &quot;react&quot;;export const ThemeContext = React.createContext('red') 2、顶级组件提供 Provider index.js12345678910111213141516171819import React from 'react'import Child from './Child'import { ThemeContext } from './res/Context'class ContextDemo extends React.Component { render() { return ( &lt;ThemeContext.Provider value={'yellow'}&gt; &lt;div className=&quot;homeWrap&quot;&gt; &lt;Child /&gt; &lt;/div&gt; &lt;/ThemeContext.Provider&gt; ) }}export default ContextDemo 3、其他组件引用容器并声明contextType属性后读取Context容器的默认值。 Child.js123456789101112131415161718192021import React, { Component } from &quot;react&quot;;import SecondChild from './SecondChild'import { ThemeContext } from './res/Context'class Child extends Component { static contextType = ThemeContext render() { return ( &lt;div className=&quot;childWrap&quot;&gt; &lt;div&gt; Child 组件的主题色：&lt;span style={{ color: this.context }}&gt;{this.context}&lt;/span&gt; &lt;/div&gt; &lt;SecondChild /&gt; &lt;/div&gt; ) }}export default Child SecondChild.js1234567891011121314151617import React, { Component } from &quot;react&quot;;import { ThemeContext } from './res/Context'class SecondChild extends Component { static contextType = ThemeContext render() { return ( &lt;div className=&quot;secondChildWrap&quot;&gt; SecondChild 组件的主题色&lt;span style={{ color: this.context }}&gt;{this.context}&lt;/span&gt; &lt;/div&gt; ) }}export default SecondChild 姿势三 创建Context对象，顶级组件提供Provider并赋予新值，子组件消费Context。 1、Context.js提供 Context 容器。 Context.js12import React from &quot;react&quot;;export const ThemeContext = React.createContext('red') 2、顶级组件提供 Provider index.js12345678910111213141516171819import React from 'react'import Child from './Child'import { ThemeContext } from './res/Context'class ContextDemo extends React.Component { render() { return ( &lt;ThemeContext.Provider value={'yellow'}&gt; &lt;div className=&quot;homeWrap&quot;&gt; &lt;Child /&gt; &lt;/div&gt; &lt;/ThemeContext.Provider&gt; ) }}export default ContextDemo 3、其他组件引用容器并声明contextType属性后，声明消费者后读取Context容器的默认值。 Child.js123456789101112131415161718192021222324252627import React, { Component } from &quot;react&quot;;import SecondChild from './SecondChild'import { ThemeContext } from './res/Context'class Child extends Component { static contextType = ThemeContext render() { return ( &lt;div className=&quot;childWrap&quot;&gt; &lt;ThemeContext.Consumer&gt; {val =&gt; { return ( &lt;div&gt; Child 组件的主题色：&lt;span style={{ color: this.context }}&gt;{this.context}&lt;/span&gt; &lt;/div&gt; ) }} &lt;/ThemeContext.Consumer&gt; &lt;SecondChild /&gt; &lt;/div&gt; ) }}export default Child SecondChild1.js (class 形式的 contextType)12345678910111213141516171819202122232425import React, { Component } from &quot;react&quot;;import { ThemeContext } from './res/Context'class SecondChild1 extends Component { static contextType = ThemeContext render() { return ( &lt;ThemeContext.Consumer&gt; { val =&gt; { return ( &lt;div className=&quot;secondChild1Wrap&quot;&gt; SecondChild 组件的主题色&lt;span style={{ color: this.context }}&gt;{val}&lt;/span&gt; &lt;/div&gt; ) } } &lt;/ThemeContext.Consumer&gt; ) }}export default SecondChild SecondChild2.js (function 形式的 useContext)123456789101112131415import React, { useContext } from &quot;react&quot;;import { ThemeContext } from './res/Context'function SecondChild2() { const context = useContext(ThemeContext) return ( &lt;div className=&quot;secondChildWrap&quot;&gt; SecondChild2 组件的主题色&lt;span style={{ color: context }}&gt;{context}&lt;/span&gt; &lt;/div&gt; )}export default SecondChild2 总结 创建对象 创建一个Context（React.createContext(defaultValue)）对象， 读取值 当 React 渲染一个订阅了这个Context对象的组件，这个组件会从组件树中离自身最近的那个匹配的Provider中读取当前 Context 的值。匹配不到 Provider时，会默认读取 defaultValue。 高阶动态更新提供 Context 容器12import React from &quot;react&quot;;export const ThemeContext = React.createContext('red') Provider 提供值和值更新函数123456789101112131415161718192021222324252627282930import React, { Component } from 'react'import { ThemeContext } from './context'import Son from './Son'class DynamicContext extends Component { constructor(props) { super(props) this.state = { theme: 'light' } } toggleTheme = (theme) =&gt; { this.setState({ theme }) } render() { return ( &lt;ThemeContext.Provider value={{ theme: this.state.theme, toggle: (val) =&gt; this.toggleTheme(val) }}&gt; &lt;Son /&gt; &lt;/ThemeContext.Provider&gt; ) }}export default DynamicContext 调用123456789101112131415161718192021222324import React, { Component } from &quot;react&quot;;import {ThemeContext} from './context'export default class GrandSon extends Component { static contextType = ThemeContext render() { return ( &lt;div&gt; &lt;p&gt;主题色为：{this.context.theme}&lt;/p&gt; &lt;button onClick={() =&gt; { if (this.context.theme === 'light') { this.context.toggle('dark') } if (this.context.theme === 'dark') { this.context.toggle('light') } }}&gt;修改主题&lt;/button&gt; &lt;/div&gt; ) }} 多引用Provider123456789101112131415161718192021import React, { Component } from 'react'import { ThemeContext, UserContext } from './context'import Son from './Son'class DynamicContext extends Component { constructor(props) { super(props) } render() { return ( &lt;ThemeContext.Provider value={'dark'}&gt; &lt;UserContext.Provider value={'小明'}&gt; &lt;Son /&gt; &lt;/UserContext.Provider&gt; &lt;/ThemeContext.Provider&gt; ) }}export default DynamicContext 123456789101112131415161718192021222324252627import React, { Component } from &quot;react&quot;;import { ThemeContext, UserContext } from './context'export default class GrandSon extends Component { render() { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; { return ( &lt;UserContext.Consumer&gt; {user =&gt; { return ( &lt;div&gt; &lt;p&gt;当前主题色：{theme}&lt;/p&gt; &lt;p&gt;当前用户：{user}&lt;/p&gt; &lt;/div&gt; ) }} &lt;/UserContext.Consumer&gt; ) }} &lt;/ThemeContext.Consumer&gt; ) }} 声明创建多个 Context 容器，然后通过提供多个 Provider 并用多个 Consumer 进行消费。 个人理解这种写法并不是好的实践。 防坑Context 使用参考标识来决定何时进行渲染，当 Provider 重新渲染（Provider 的 value 属性改变）时，Provider 的子组件也会触发渲染。 官网说明参考文章","link":"/2020/11/18/React/Context/"},{"title":"说说 React 系列之：Refs","text":"引言 Refs 提供了一种方式，允许我们访问 DOM 节点或子组件实例 缘由回想在 React 开发中，是不是有些场景可能会需要直接获取 DOM 节点（eg：input 元素获取焦点、video 播放视频）；又有些场景，父组件想直接调用子组件的方法或者获取子组件的成员变量。 所以为了满足这两种场景，React 提供了 Ref 这个能力。 通过 Ref 我们可以达到以下两种目的： 引用子组件实例 访问 DOM 节点 使用React 的 Ref 有三种使用姿势： createRef（React 16.3） 回调 字符串 string 类型的 refs 存在一些问题被逐渐废弃。 createRefAPI 形式有以下几个步骤： 创建：this.inputRef = React.createRef() 挂载：ref = {ref = this.inputRef} 使用：this.inputRef.current.focus()1234567891011121314151617181920import React, { Component } from &quot;react&quot;;export default class RefDemo extends Component { inputRef = React.createRef() focus = () =&gt; { this.inputRef.current.focus() } render() { return ( &lt;div&gt; &lt;h4 className=&quot;name&quot;&gt;React.createRef()&lt;/h4&gt; &lt;input type=&quot;text&quot; ref={this.inputRef} /&gt; &lt;button onClick={this.focus}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; ) }} 回调 Refs回调 Refs 形式有以下几个步骤： 创建：this.inputRef = null 挂载：ref = {ref =&gt; this.inputRef = ref} 使用：this.inputRef.focus() 12345678910111213141516171819import React, { Component } from &quot;react&quot;;export default class RefDemo extends Component { inputRef = React.createRef() focus = () =&gt; { this.inputRef.focus() } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={ref =&gt; this.inputRef = ref} /&gt; &lt;button onClick={this.focus}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; ) }} StringString 形式有以下几个步骤： 创建且挂载：ref =&quot;inputRef&quot; 使用：this.refs.inputRef.focus() 12345678910111213141516171819import React, { Component } from &quot;react&quot;export default class RefDemo extends Component { inputRef = null focus = () =&gt; { this.refs.inputRef.focus() } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;inputRef&quot; /&gt; &lt;button onClick={this.focus}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; ) }} ref 的值根据使用方式、节点类型不同而有所不同： 使用方式： createRef：this.inputRef.current（ref 值从 current 获取） 回调：this.inputRef（ref 值从自身获取） String：this.refs.inputRef（ref 挂载到了实例属性 refs上，而且没有 current） 节点类型 作用于 HTML 元素，ref 的值为对 DOM 元素的引用 作用于 class 组件，ref 的值为对组件实例的引用 Refs 和函数组件 函数组件上默认情况下，函数组件上不能使用 ref 属性，因为他们没有实例。如果要在函数组件上使用，可以通过 forwardRef 或者将其转换成 class 组件。 函数组件中函数组件中可以通过 useRef 实现 Ref 功能 useRef1234567891011121314151617import React, { Component, useRef } from &quot;react&quot;;function ChildFunc() { const ref = useRef() return ( &lt;div&gt; &lt;h4&gt;ChildFunc&lt;/h4&gt; &lt;input type=&quot;text&quot; ref={ref} /&gt; &lt;button onClick={() =&gt; { ref.current.focus() }}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; )}export default ChildFunc forwardRef场景：父子组件嵌套场景条件：子组件为函数组件目的：父组件可以直接获取子组件的 DOM 属性 父组件123456789101112131415161718192021import React, { Component } from &quot;react&quot;;import ChildFunc from './ChildFunc';export default class RefDemo extends Component { funRef = React.createRef() focus = () =&gt; { this.funRef.current.focus() } render() { return ( &lt;div&gt; &lt;ChildFunc ref={this.funRef}&gt;&lt;/ChildFunc&gt; &lt;button onClick={this.focus}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; ) }} 子组件123456789101112import React, { forwardRef } from &quot;react&quot;;function ChildFunc(props, ref) { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={ref} /&gt; &lt;/div&gt; )}export default forwardRef(ChildFunc) useImperativeHandleuseImperativeHandle 可以结合forwardRef实现自定义暴露给父组件的实例属性。 父组件123456789101112131415161718import React, { Component } from &quot;react&quot;;import ChildFunc from './ChildFunc';export default class RefDemo extends Component { funRef = React.createRef() render() { return ( &lt;div&gt; &lt;ChildFunc ref={this.funRef}&gt;&lt;/ChildFunc&gt; &lt;button onClick={() =&gt; { this.funRef.current.focus() }}&gt;获取焦点&lt;/button&gt; &lt;/div&gt; ) }} 子组件12345678910111213141516171819import React, { useRef, forwardRef, useImperativeHandle } from &quot;react&quot;;function ChildFunc(props, ref) { const inputRef = useRef() useImperativeHandle(ref, () =&gt; ({ focus: () =&gt; { inputRef.current.focus() } })) return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={inputRef} /&gt; &lt;/div&gt; )}export default forwardRef(ChildFunc) 挂载过程React 会在组件挂载时给 current 传入值，并在组件卸载时传入 null 回调形式：组件挂载时，调用回调函数并传入 DOM 元素，卸载时调用回调函数并传入 null。在 componentDidMount 或 componentDidUpdate 触发前，React 会保证 refs 一定是最新的。 防坑 避免使用 refs 来做任何可以通过声明式实现来完成的事情 举个栗子，避免在 dialog 组件里暴露 open()和 close()方法，最好传递 isOpen 属性。 勿过度使用 Refs 需要获取 DOM 节点的场景不可避免外，获取子组件引用其实很多情况可以通过诸如’状态提升’等方式规避 备注 1：中文官网翻译文案有：”Refs 提供了一种方式，允许我们访问 DOM 节点（或在 render 方法中创建的 React 元素？）”，表述合适吗？","link":"/2020/11/27/React/Ref/"},{"title":"State","text":"关于 setState() 你应该了解三件事： 不要直接修改 State State 的更新可能是异步的 State 的更新会被合并 向下流动任何的 state 总是属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中低于他们的组件。","link":"/2019/05/06/React/State/"},{"title":"插槽","text":"Vue 中有对插槽及作用域插槽的设计，但遗憾的是 React 中并没有。虽然 React 中并没有针对组件插槽的开发范式设计，但因此可能显得更为灵活和自由。 React 中使用插槽的几种形式如下： 1、props.children123456789101112131415161718// Slot.jsexport default function SlotDemo (props) { return ( &lt;div className=&quot;slot-demo-wrap&quot;&gt; {props.children} &lt;/div&gt; )}// App.jsReactDom.render( &lt;Slot&gt; &lt;p&gt;内部 slot1&lt;/p&gt; &lt;p&gt;内部 slot2&lt;/p&gt; &lt;/Slot&gt;, document.getElementById('root'),) 2、props12345678910111213141516171819202122// Slot.jsexport default function SlotDemo (props) { return ( &lt;div className=&quot;slot-demo-wrap&quot;&gt; &lt;div className=&quot;left-slot&quot;&gt; {props.leftSlot} &lt;/div&gt; &lt;div className=&quot;right-slot&quot;&gt; {props.rightSlot} &lt;/div&gt; &lt;/div&gt; )}// App.jsconst leftSlot = &lt;p&gt;左侧 slot&lt;/p&gt;const rightSlot = &lt;p&gt;右侧 slot&lt;/p&gt;ReactDom.render( &lt;Slot leftSlot={leftSlot} rightSlot={rightSlot}/&gt;, document.getElementById('root'),) 3、关于组合和继承在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。","link":"/2019/06/18/React/%E6%8F%92%E6%A7%BD/"},{"title":"条件渲染","text":"条件渲染的几种形式 1、变量值判断1234567891011121314151617181920// 形式 1renderGreeting () { const { isLogin } = this.state if (isLogin) return &lt;div&gt;欢迎登录&lt;/div&gt; else return &lt;div&gt;请注册&lt;/div&gt;}// 形式 2renderGreeting () { const { isLogin } = this.state let greeting if (isLogin) greeting = &lt;div&gt;欢迎登录&lt;/div&gt; else greeting = &lt;div&gt;请注册&lt;/div&gt;} 2、与运算1234567891011renderUnReadMessage () { const { unreadMessages } = this.state return ( &lt;div className=&quot;unread-message&quot;&gt; {unreadMessages.length &gt; 0 &amp;&amp; ( &lt;p&gt;You have {unreadMessages.length} unread messages.&lt;/p&gt; )} &lt;/div&gt; )} 3、三目运算符1234567891011render() { const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; {isLoggedIn ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt; : &lt;LoginButton onClick={this.handleLoginClick} /&gt; } &lt;/div&gt; );} 返回 JSX 为 null 的情况，组件不会渲染，但生命周期依然执行","link":"/2019/06/16/React/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"},{"title":"React 组件通信方式","text":"引言 组件通信方式一定是基于组件彼此的相对位置关系这个前提而言的，而组件相对位置分为两大类： 嵌套 非嵌套 嵌套关系直接嵌套（父子组件）123456789101112131415161718192021222324const Child = (props) =&gt; { return ( &lt;div className=&quot;child&quot; onClick={() =&gt; { props.nameClick(Date.now()) }}&gt; {props.name} &lt;/div&gt; )}const Parent = () =&gt; { return ( &lt;div className=&quot;parent&quot;&gt; &lt;Child name=&quot;亦凡&quot; nameClick={(val) =&gt; { console.log(val) }}/&gt; &lt;/div&gt; )}ReactDOM.render( &lt;Parent/&gt;, document.getElementById('root')); 父、子组件传递信息一般依靠 props 特性。父组件通过 props 向下传递数据，子组件通过 props 中的事件向上传递数据，这是最常见的通信形式。 非直接嵌套（跨级组件）跨级组件可以按照父子组件props的形式逐层传递数据，但缺点很明显，太繁琐了。一般会采用Context特性来实现通信。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const {useState} = React const Context = React.createContext({}) const GrandPa = () =&gt; { let [theme, setTheme] = useState('red') return ( &lt;Context.Provider value={ { theme: theme, updateTheme: (val) =&gt; { setTheme(val) } } }&gt; &lt;div className=&quot;grandpa&quot; style={{color: theme}}&gt; &lt;h2&gt;Grandpa组件颜色值：{name}&lt;/h2&gt; &lt;Parent/&gt; &lt;/div&gt; &lt;/Context.Provider&gt; ) } const Parent = () =&gt; { return ( &lt;Context.Consumer&gt; {(context) =&gt; { return ( &lt;div className=&quot;parent&quot; style={{color: context.theme}}&gt; &lt;h3&gt;父组件颜色值：{context.theme}&lt;/h3&gt; &lt;Child/&gt; &lt;/div&gt; ) }} &lt;/Context.Consumer&gt; ) } const Child = () =&gt; { return ( &lt;Context.Consumer&gt; {(context) =&gt; { return ( &lt;div className=&quot;child&quot; style={{color: context.theme}}&gt; &lt;h4&gt;子组件颜色值：{context.theme}&lt;/h4&gt; &lt;input type=&quot;text&quot; onInput={(e) =&gt; { context.updateTheme(e.target.value) }}/&gt; &lt;/div&gt; ) }} &lt;/Context.Consumer&gt; ) } ReactDOM.render( &lt;GrandPa/&gt;, document.getElementById('root') ); 关于 Context 的更多内容可参看： 官方文档 非嵌套非嵌套关系的组件通信：即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件等。 可以使用自定义事件通信（发布订阅模式） 如果是兄弟组件，可以借用共同的父组件作为桥接进行通信 可以通过 redux 等全局状态管理","link":"/2020/11/16/React/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"title":"CSS Grid 都出来了，你还不会 Flex 吗","text":"Flex 是 flexible box （可伸缩盒子）的简称。 传统的布局解决方案： 基于 table（CSS3.0 未实现之前的方案，已废弃） 基于盒模型，依赖于 display 、 position 、 float 属性 传统布局多少有失灵活性和不方便性，flex 则进行了相应的提升。 1、基本概念采用 Flex 布局的元素，称为 Flex 容器，他的所有子元素自动成为容器成员，称为 Flex 项目（flex item）。 容器默认存在两根轴：主轴（main axis）和交叉轴（cross axis） 主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end 交叉轴的开始位置叫做 cross start，结束位置叫做 cross end 项目默认沿主轴排列，单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size 2. 容器属性Flex 容器有以下 6 个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content 2.1、flex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）： 123.box { flex-direction: row | row-reverse | column | column-reverse;} 2.2、flex-wrapflex-wrap 决定 flex item 超出一排长度时是否换行。 默认为不换行 flex item 对于宽度的分割按照 width 、 flex 属性的定义，如果都为 width 而且超出了，则会被压缩，否则按照 flex 属性的定义分割 123.box { flex-wrap: nowrap | wrap | wrap-reverse;} 2.3、flex-flowflex-flow 是 flex-direction 和 flex-wrap 的缩写。 123.box { flex-flow: &lt;flex-direction&gt; | &lt;flex-wrap&gt; ;} 2.4、justify-contentjustify-content 属性定义了 flex-item 在主轴上的对齐方式。 123.box { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;} 2.5、align-itemsalign-items 属性定义 flex item 在交叉轴上如何排列。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 2.6、align-contentalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch;} 3、项目属性Flex 容器有以下 6 个属性： order flex-grow flex-shrink flex-basis flex align-self3.1、order order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 3.2、flex-growflex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 比如：如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3.3、flex-shrinkflex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 比如：如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。 3.4、flex-basisflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto ，即项目的本来大小。 它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。 3.5、flexflex 属性是 flex-grow , flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 。后两个属性可选。 3.6、align-selfalign-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。 参考文档： https://xluos.github.io/demo/flexbox/ http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html","link":"/2017/03/05/CSS/%E5%B1%9E%E6%80%A7/Flex/"},{"title":"像素之说","text":"css 像素：px 物理像素：pt（设备像素） 分辨率 像素比：dpr-device pixel ratio （1px = dpr^2 * 1pt） 设备独立像素：dip-device independent pixel（又称逻辑像素） ppi：pixel per inch（每一英寸拥有的像素数）像素密度，衡量单位面积内的拥有像素值的情况 retina 显示屏 疑问： 为什么 iOS 有@1、@2、@3 的区别？ 1. PX像素，为显示影像的基本单位。译自 pixel ， pixel 为 picture element 的缩写。像素是相对单位。 2. DP物理像素， device pixel 。顾名思义，物理意义上的点阵集，单位是 PT，是绝对单位，即每个屏幕的物理像素是固定的。 分辨率","link":"/2019/01/02/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%83%8F%E7%B4%A0%E4%B9%8B%E8%AF%B4/"},{"title":"布局之居中","text":"页面如下结构： 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;内容&lt;/div&gt;&lt;/div&gt; 1、水平居中123456789101112131415161718192021222324252627282930// margin: 0 auto;.parent { .child { margin: 0 auto; }}// text-align + inline-block.parent { text-align: center; .child { display: inline-block; }}// absolute + translate.parent { position: relative; .child { position: absolute; left: 50%; transform: translateX(-50%); }}// flex.parent { display: flex; justify-content: center;} 2、垂直居中123456789101112131415161718192021// table-cell + vertical-align.parent { display: table-cell; vertical-align: middle;}// absolute + translate.parent { position: relative; .child { position: absolute; top: 50%; transform: translateY(-50%); }}// flex.parent { display: flex; align-items: center;} 3、垂直、水平居中123456789101112131415161718192021222324252627// absolute + translate.parent { position: relative; .child { position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); }}// table-cell、text-align.parent { display: table-cell; vertical-align: middle; text-align: center; .child { display: inline-block; }}// flex.parent { display: flex; justify-content: center; align-items: center;}","link":"/2017/02/27/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%B1%85%E4%B8%AD/"},{"title":"Less 笔记","text":"1、variable 1.1、通用1234567891011@link-color: #08aaef;@hover-color: darken(@link-color, 10%);a,a.link { color: @link-color;}a:hover { color: @hover-color;} 输出为： 1234567a,a.link { color: #08aaef;}a:hover { color: #0687be;} 1.2、插值上面的例子着重于使用变量来控制 CSS 规则中的值，但是它们也可以在其他地方使用，例如选择器名称、属性名称、url 和 @import 语句。 插值的使用形式为 @{variable-name} 拼接其他字符串或者单独使用。 1.2.1、选择器1234567@btn-prefix: ivu;.@{btn-prefix}-primary { border-radius: 5px; border: 1px solid #08aaef; color: #08aaef;} 输出为： 12345.ivu-primary { border-radius: 5px; border: 1px solid #08aaef; color: #08aaef;} 1.2.2、属性名123456@property-color: color;.widget { @{property-color}: #08aaef; background-@{property-color}: #e1e1e1;} 输出为： 1234.widget { color: #08aaef; background-color: #e1e1e1;} 1.2.3、URLs123456@images: '../../assets/images';.banner { background: url('@{images}/home/bg.png') no-repeat; background-size: 100% 100%;} 输出为： 1234.banner { background: url('../../assets/images/home/bg.png') no-repeat; background-size: 100% 100%;} 1.2.4、import1234@styles: '../../assets/styles';@import '@{styles}/variable.less';@import '@{styles}/mixin.less'; 1.3、变量中的变量在Less中，可以使用另一个变量定义一个变量的名称。 12345678910@primary: green;@secondary: blue;.section { @color: primary; .element { color: @@color; }} 输出为： 123.section .element { color: green;} 1.4、变量提升 Less 中的变量提升与 JavaScript 语言中的变量提升相同 Less 中的作用域原则与 JavaScript 语言中的作用域原则相同 2、&amp; 2.1、通用&amp; 运算符表示嵌套规则中对父选择器的引用。 1234567a { color: blue; &amp;:hover { color: lighten(blue, 10%); }} 输出为： 123456a { color: blue;}a:hover { color: #3333ff;} 2.2、插值12345678910111213.button { &amp;-ok { color: green; } &amp;-warning { color: yellow; } &amp;-error { color: red; }} 输出为： 123456789.button-ok { color: green;}.button-warning { color: yellow;}.button-error { color: red;} 2.3、复合1234567891011121314151617.button { &amp; &amp; { color: yellow; } &amp;&gt;&amp; { color: black; } &amp;+&amp; { color: white; } &amp;&amp; { color: red; }} 输出为： 123456789101112.button .button { color: yellow;}.button &gt; .button { color: black;}.button + .button { color: white;}.button.button { color: red;} 2.4、改变顺序12345div { a &amp; { color: red; }} 输出为： 123a div { color: red;} 2.5、组合12345p, div, a { &amp; + &amp; { color: red; }} 输出为： 1234567891011p + p,p + div,p + a,div + p,div + div,div + a,a + p,a + div,a + a { color: red;} 2.6、注意&amp; 表示所有嵌套选择器，而不是最近的父级。如下： 123456789div { p { a { &amp;:hover { color: white; } } }} 输出为： 123div p a:hover { color: white;} 而不是： 123a:hover { color: white;} 3、extendextend 是 less 中的一个伪类语法，负责将一个或一些选择器中的声明继承到指定选择器中。 3.1、语法12.b { color:red; }.a:extend(.b) { background: white; } 意为 a 选择器将继承 b 选择器的规则集，输出为： 12.b, .a { color:red; }.a { background: white; } 该语法的形式有如下几种： 跟在选择器之后：.a:extend(.b) 带空格： .a :extend(.b) 多个串联： .a:extend(.f):extend(.g) 只能跟在最后：因此 pre:hover:extend(div pre):nth-child(odd) 是不允许的 pre:hover:extend(.a):extend(.b) 等同于 pre:hover:extend(.a,.b) 选择器嵌套情形遵从上面原则 3.2、多重继承12345.a:extend(.f){}.a:extend(.g){}// 等同于.a:extend(.f,.g){} 统一输出为： 123.f,.a {}.g,.a {}.a {} 3.3、精准匹配默认情况下，less 在为 extend 查找继承选择器时，遵从精准匹配策略。即选择器形式必须完全统一才能匹配，如下列举的情况： .text:extend(.class) 与 .a.class 、.class.a 、.class &gt; .a 、.a &gt; .class、 *.class 不匹配 .text:extend(a:hover:visited) 与a:visited:hover 不匹配 .text:extend(:nth-child( 1n + 3 )) 与 :nth-child(n+3) 不匹配 但属性选择器的单双引号情况例外： .text:extend([title=identifier]) 与 [title='identifier'] 和 [title=&quot;identifier&quot;] 匹配 3.4、all1234567891011.a.b.test,.test.c { color: orange;}.test { &amp;:hover { color: green; }}.replacement:extend(.test all) {} 输出为： 12345678910.a.b.test,.test.c,.a.b.replacement,.replacement.c { color: orange;}.test:hover,.replacement:hover { color: green;} 3.5、选择器插值略 3.6、media 作用域作用域规则可类比 JavaScript 语言中的变量作用域，以 media 花括号为作用域范畴。 3.7、经典场景 3.7.1、减少基类123456789101112// CSS.animal { color: white; background-color: red;}.bear { color: black;}// HTML&lt;a classs=&quot;animal bear&quot;&gt;&lt;/a&gt; 可改为： 12345678910111213// CSS.animal { color: white; background-color: red;}.bear { &amp;:extend(.animal); color: black;}// HTML&lt;a classs=&quot;bear&quot;&gt;&lt;/a&gt; 3.7.2、减少重复1234567891011121314151617181920.my-inline-block() { display: inline-block; font-size: 0;}.thing1 { .my-inline-block;}.thing2 { .my-inline-block;}// 输出为.thing1 { display: inline-block; font-size: 0;}.thing2 { display: inline-block; font-size: 0;} 可改为： 123456789101112131415161718.my-inline-block { display: inline-block; font-size: 0;}.thing1 { &amp;:extend(.my-inline-block);}.thing2 { &amp;:extend(.my-inline-block);}// 输出为.my-inline-block,.thing1,.thing2 { display: inline-block; font-size: 0;} 4、merge合并：将多个属性的值合并到单个属性下的逗号或空格分隔的列表中，合并对于诸如背景和变换之类的属性很有用。 123456789101112131415161718192021222324252627282930// 不合并.mixin() { box-shadow: inset 0 1px 10px #e55;}.class { .mixin(); box-shadow: 0 0 20px black;}// 输出为.class { box-shadow: inset 0 1px 10px #e55; box-shadow: 0 0 20px black;}// 合并.mixin() { box-shadow+: inset 0 1px 10px #e55;}.class { .mixin(); box-shadow+: 0 0 20px black;}// 输出为.class { box-shadow: inset 0 1px 10px #e55, 0 0 20px black;} 语法： 逗号分隔： + 空格分隔： +- 5、mixins 5.1、语法1234567891011.class-name, #id-name { color: red;}.mixin-class { .class-name();}.mixin-id { #id-name();} 输出为： 12345678910.class-name,#id-name { color: red;}.mixin-class { color: red;}.mixin-id { color: red;} 5.2、不输出123456789101112.mixin-a { color: red;}.mixin-b() { color: green();}.class-a { .mixin-a(); .mixin-b();} 输出为： 1234567.mixin-a { color: red;}.class-a { color: red; color: green;} 5.3、Selectors in MixinsMixins 不仅可以包含属性，还可以包含其他的选择器。 1234567891011.mixin-hover() { color: red; &amp;:hover { background-color: white; }}button { .mixin-hover();} 输出为： 123456button { color: red;}button:hover { background-color: white;} 5.4、Namespace 减少与其他库混合使用时的冲突 一种组织 mixins 的方法 123456789101112#outer() { .inner-a { color: red; } .inner-b { color: green; }}.c { #outer &gt; .inner-a();} 5.5、守卫1234567#namespace when (@mode = huge) { .mixin() { /* */ }}#namespace { .mixin() when (@mode = huge) { /* */ }} 5.6、important123456789101112.foo(@bg: #e55, @color: #4e5) { background-color: @bg; color: @color;}.unimportant { .foo();}.important { .foo() !important;} 输出为： 12345678.unimportant { background-color: #e55; color: #4e5;}.important { background-color: #e55 !important; color: #4e5 !important;} 5.7、传参数略，待补充。 6、import @import 语句可以在文档的任何位置（区别于 css 中的只能在头部） 根据文件扩展名的不同， import 语句的处理方式可能会有所不同 @import “foo”; // foo.less is imported @import “foo.less”; // foo.less is imported @import “foo.php”; // foo.php imported as a Less file @import “foo.css”; // statement left in place, as-is 6.1、选项Syntax: @import (keyword) &quot;filename&quot;; reference: use a Less file but do not output it inline: include the source file in the output but do not process it less: treat the file as a Less file, no matter what the file extension css: treat the file as a CSS file, no matter what the file extension once: only include the file once (this is default behavior) multiple: include the file multiple times optional: continue compiling when file is not found 7、Maps略，待补充。","link":"/2018/04/01/CSS/%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/less/"},{"title":"Class","text":"一、概述 1. ES5ES5 中用构造函数来实现类和实例： 12345678function Person() {this.type = 'person'}Person.prototype.sayType = function () {return this.type}const personA = new Person()personA.sayType() ### 2. ES6 基本上，ES6 的 class 可以看做只是 ES5构造函数的语法糖，上面代码用 ES6 来实现如下： 1234567891011121314151617class Person { constructor() { this.type = 'person' } sayType() { return this.type } }const personA = new Person()personA.sayType() // persontypeof Person // functionPerson.prototype.constructor === Person // true ** 二、特性 1. 属性位置与 ES5 一样，实例的属性除非显示定义在其自身（即定义在 this 对象上），否则都是定义在原型上。** 12345678910111213141516171819class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')' }}const point = new Point(2,3)point.x // 2point.y // 3point.hasOwnProperty(x) // truepoint.hasOwnProperty(y) // truepoint.hasOwnProperty(toString) // false ### 2. 共享原型对象 123456class Point {}const point1 = new Point(2,3)const point2 = new Point(4,5)point1.__proto__ === point2.__proto__ ### 3. 属性表达式 类的属性名，可以采用表达式 12345let getName = 'getName'class Point { [getName](){}} ### 4. 不存在变量提升 12new Point() // Uncaught ReferenceError: Point is not definedclass Point {} ### 5. Generator 方法 如果在某个方法前加上星号（ * ），就表示该方法是一个 Generator函数。 123456789101112131415161718class Foo { constructor(...args) { this.args = args } *[Symbol.iterator]() { for (const iterator of this.args) { yield iterator } }}let foo = new Foo('hello', 'world')console.log(foo)for (const iterator of foo) { console.log(iterator)} ### 6. this 指向 类的方法内部的 this 默认指向该类的实例，但不小心也可能丢失（如 React 中 render 的事件绑定），至于具体为啥，可参考 this 指向一节（TODO）。显示绑定上下文对象，有以下几种形式： 12345678910111213141516171819class Person { constructor() { this.name = name this.sex = sex this.age = age this.getName = () =&gt; this.getName() // 形式 1 this.getAge = this.getAge.bind(this) // 形式 2 } getName() { } getAge() { } // 形式 3 getSex = () =&gt; { }} ## 三、静态属性 区别于实例属性，可以直接通过类调用的方法称为静态属性。 1. this 指向12345678910111213class Person { static getSelfName() { return this.name // Person } constructor({ name, sex, age }) { this.name = name this.sex = sex this.age = age }}Person.getSelfName() // Person ‌ 2. 继承 子类可以继承父类的静态属性123456789class Person { static getSelfName() { return this.name }}class Student extends Person {}Student.getSelfName() 通过 super 调用12345678910111213class Person { static getSelfName() { return this.name }}class Student extends Person { static getParentName() { return super.getSelfName() }}Student.getParentName() // Student ## 四、私有属性 在属性名称之前加 # 符号，可以声明此属性为私有的，即外部不可访问的。 12345678910111213141516class Person { #count = 1 getCount() { return this.#count } #getCount() { return this.#count }}let person = new Person()person.getCount() // 1person.#getCount() // Uncaught SyntaxError: Private field '#count' must be declared in an enclosing classperson.#count // Uncaught SyntaxError: Private field '#count' must be declared in an enclosing class ‌ 五、静态私有属性私有属性和私有方法前面，也可以加上static关键字，表示这是一个静态的私有属性或私有方法。 1234567891011121314151617181920class FakeMath { static PI = 22 / 7; static #totallyRandomNumber = 4; static #computeRandomNumber() { return FakeMath.#totallyRandomNumber; } static random() { console.log('I heard you like random numbers…') return FakeMath.#computeRandomNumber(); }}FakeMath.PI // 3.142857142857143FakeMath.random()// I heard you like random numbers…// 4FakeMath.#totallyRandomNumber // 报错FakeMath.#computeRandomNumber() // 报错 六、其他 ### 1. new.target new 是从构造函数生成实例对象的命令。ES6 为 new 命令引入了一个 new.target 属性，该属性只能用在类中的构造函数中，返回 new 命令作用于的那个构造函数。如果不是通过 new 命令或者 Reflec.construct() 调用， new.target 会返undefined 。 1234567891011121314151617// 形式 1class Person { constructor() { if (new.target === undefined) { throw new Error('必须使用 new 生成实例') } }}// 形式 2class Person { constructor() { if (new.target !== Person) { throw new Error('必须使用 new 生成实例') } }} 七、继承","link":"/2019/11/09/JavaScript/ES6/Class/"},{"title":"解构赋值","text":"本质上，解构赋值这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 一、数组的解构赋值12345678910// 常规let [a, b] = [0, 1] // a: 0, b: 1// 不完全解构let [a, , c] = [0, 1, 2] // a: 0, c: 1// 嵌套let [x, [y], z] = [0, [1], 2] // x: 0, y: 1, z: 2 二、对象的解构赋值123456789101112131415161718// 常规let { foo } = { foo: 'foo' } // foo: 'foo'// 未匹配let { foo } = {} // undefined// 重命名let { foo: baz } = { foo: 'foo' } // baz: 'foo'// 默认值let { foo = 'foo' } = {} // foo: 'foo'// 批量let { foo, bar: baz } = { foo: 'foo', bar: 'bar' }// 多级嵌套let { foo: { bar } } = { foo: { bar: 'bar' } } // bar: 'bar'（此处foo 只是模式，不是变量） 三、可迭代类型 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 1234567891011121314// 从函数返回多个值function example() { return [1, 2, 3]}let [a, b, c] = example() // a: 1, b: 2, c: 3function example2() { return { x: 'x', y: 'y', z: 'z' }}let { x, y, z } = example2() // x: 'x', y: 'y', z: 'z'// 字符串let [a, b, c] = 'abc' // // a: 'a', b: 'b', c: 'c' 四、其他1234567// 对象嵌套let { foo: { bar } } = { foo: { bar: 'bar' } } // bar: 'bar'（此处foo 只是模式，不是变量）let { foo, foo: { bar } } = { foo: { bar: 'bar' } } // foo: {bar: 'bar'}, bar: 'bar'// 对象的解构赋值可以取到继承的属性let { sort } = [1, 2, 3]let { length } = 'abc' 五、异常场景1234567891011121314// 模式匹配抛错// ncaught TypeError: undefined is not a functionlet [a, [b], c] = [1, 2, 3]// Uncaught TypeError: Cannot read property 'bar' of undefinedlet { foo: { bar } } = {}// undefined 和默认值// ES6 内部使用严格相等运算符（===），判断一个位置是否有值// 所以，只有当一个数组成员严格等于undefined，默认值才会生效let [x = 1] = [] // x = 1let [x = 1] = [undefined] // x = 1let [x = 1] = [null] // x = null 六、应用场景123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.交换变量let a = 'a'let b = 'b'let [b, a] = [a, b] // a: 'b', b: 'a'// 2.函数入参function foo([x, y, z]) { }function foo([x = 'x', y, z]) { }function foo([x = 'x', y, z] = []) { }function foo({ foo, bar: baz, zab = 'zab' }) { }function foo({ foo, bar: baz, zab = 'zab' } = {}) { }// 3.网络请求结果 json 数据let resp = { code: 10000, data: { foo: 'foo', bar: 'bar' }, msg: 'success' }$.ajax().then(({ code, data = {} }) =&gt; { console.log(data)})// 4.内置对象方法取值const { sin, cos, random } = Mathconst { log, error, group } = console// 5.输入模块方法取值import React from 'react'const { Component, useState, useEffect } = Reactlet { readFile, resolve } = require('path')// 6.取数组的首末元素let arr = [1, 2, 3, 4, 5]let { 0: first, [arr.length - 1]: last } = arr// 7.遍历 Map 结构// for (let item of map) {// console.log(`${item[0]} is ${item[1]}`)// }let map = new Map()map.set('first', 'hello')map.set('second', 'world')for (let [key, value] of map) { console.log(`${key} is ${value}`)}","link":"/2019/11/17/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"对象属性描述符","text":"","link":"/2020/02/25/JavaScript/Feature/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"title":"真假值和相等性判断","text":"1、真假值以下六个均为 not truthy 的值： false 0 “” null undefined NaN 除以上六个外，其余情况均为 truthy 的值，如： if ({}) if ([]) 2、相等性JavaScript 中的相等性判断","link":"/2019/03/12/JavaScript/Feature/%E7%9C%9F%E5%81%87%E5%80%BC%E5%92%8C%E7%9B%B8%E7%AD%89%E6%80%A7%E5%88%A4%E6%96%AD/"},{"title":"webpack 配置","text":"因为 @vue/cli-service 对 webpack 配置进行了抽象，如果想修改或者添加部分 webpack 的配置，可通过以下几种方式： @vue/cli-service 暴露出的可配置内容 package.json 中的 vue 字段； vue.config.js 文件； @vue/cli-service 未暴露出的其他 webpack 配置内容 vue.config.js 中的 configureWebpack 字段； vue.config.js 中的 chainWebpack 字段； 一、系统可配具体可对照查看官方文档：https://cli.vuejs.org 二、configureWebpack该属性值将会被 webpack-merge 合并入最终的 webpack 配置。 2.1 对象方式12345678910111213// vue.config.jsmodule.exports = { // other config item... configureWebpack: { resolve: { alias: { '@views': path.resolve(__dirname, './src/views'), '@images': path.resolve(__dirname, './src/images'), '@components': path.resolve(__dirname, './src/components') } } },} 2.2 函数方式1234567891011121314151617181920// vue.config.jsmodule.exports = { // other config item... configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置 } else if (process.env.NODE_ENV === 'test') { // 为测试环境修改配置 } else { // 为开发环境修改配置 } // 注意：对象直接赋值有可能覆写原有的配置 config.resolve.alias['@views'] = path.resolve(__dirname, './src/views') config.resolve.alias['@images'] = path.resolve(__dirname, './src/images') config.resolve.alias['@components'] = path.resolve(__dirname, './src/components') }, } 三、chainWebpackVue CLI 内部的 webpack 配置是通过 webpack-chain 维护的， vue.config.js 中也开放了针对此库的形式的配置。 总结：有些 webpack 选项是基于 vue.config.js 中的值设置的，所以不能修改。保险起见，将所有的 webpack配置项分为两类： vue cli 配置文件开放出来的配置项，也就是 vue.config.js 中支持的配置项，均在 vue.config.js 中配置； 非vue cli 开放出来的配置项均可以通过 configureWebpack 或者 chainWebpack 配置","link":"/2019/04/28/Vue/CLI/webpack%20%E9%85%8D%E7%BD%AE/"},{"title":"环境变量和模式","text":"一、模式 1.1 内嵌模式npm script 命令涉及的模式有 3 种 production：vue-cli-service build 和 vue-cli-service test:e2e test：vue-cli-service test:unit development：vue-cli-service serve 1.2 自定义模式可以通过传递 --mode 选项参数可以为命令行覆写默认的模式，eg： vue-cli-service build --mode staging 二、环境文件 .env 是不区分模式的环境变量配置文件，所有模式均会被加载； .env.[mode] 是特定某种模式下的环境变量配置文件，只在特定模式下加载； 每种模式都可以创建一份 local 模式文件，被 git 忽略，同模式下优先级更高； 优先级规则 .env.[mode].local &gt; .env.[mode] （同理：.env.local &gt; .env） .env.[mode] &gt; .env 环境变量配置文件读取顺序： .env &gt; .env.local &gt; .env.[mode] &gt; .env.[mode].local 后读取优先级则更高（相当于覆盖同名变量） 三、环境变量 3.1 自定义变量12345// 1. VUE_APP_开头VUE_APP_APPID=wx971b57edf7ea3fd2// 任意格式FOO=bar 只有以 VUE_APP_ 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中，可以这样访问： JavaScript 中：process.env.VUE_APP_XXX ； HTML 中： &lt;%= process.env.VUE_APP_XXX =&gt; 3.2 特殊变量除了 VUE_APP_* 变量之外，在你的应用代码中始终可用的还有两个特殊的变量： NODE_ENV - 可能是 production 、 test 、 development 或者自定义的模式名称 BASE_URL - 始终和 vue.config.js 中的 publicPath 选项相符，即你的应用汇部署到的基础路径 四、NODE_ENV NODE_ENV 挂载于 process.env 对象下，本身是不存在的，只有命令行显示指定才可用，新版 Vue Cli 中做了封装，对应模式都可以直接获取，也可以自定义 命令行指定后可直接在配置文件(webpack.config.js)中使用 如果需要在业务代码中使用，需要显示嵌入 webpack4 之前使用 DefinePlugin webpack4 之后使用 mode 详细介绍可以查看：NODE_ENV到底是个什么玩意？？","link":"/2019/04/19/Vue/CLI/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"title":"生命周期","text":"","link":"/2018/08/18/Vue/Feature/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"语义化版本 2.0.0","text":"摘要版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 简介在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。 语义化版本控制规范（SemVer）以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。） 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 修订号 Z（x.y.Z | x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。 主版本号 X（X.y.z | X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。 为什么要使用语义化的版本控制？这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。 FAQ在 0.y.z 初始开发阶段，我该如何进行版本控制？最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。 如何判断发布 1.0.0 版本的时机？当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。 这不会阻碍快速开发和迭代吗？主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。 对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。 为整个公共 API 写文件太费事了！为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。 万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。 如果我更新了自己的依赖但没有改变公共 API 该怎么办？由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。 如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。 我该如何处理即将弃用的功能？弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。 语义化版本对于版本的字串长度是否有限制呢？没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。","link":"/2019/10/11/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC/"},{"title":"Vue 和 React","text":"为什么 React 比 Vue 火React的灵活性高于Vue，这就决定了它的上限。为什么说React的灵活性高于Vue？理由一：模板。我们来可以对比下React的jsx和vue的模板：JSX其实是一种语法糖，因为最终经过编译后实际上就是React.createElement，所以我认为他不是模板是语法糖，但他能提供类似模板的直观表现形式，且跟JS语言完美的融合在一起，如果你非要把他看做模板，那也是个具有图灵完备的模板语法，简直完美，而且还不需要额外学习新的模板语言，你只需要学习好JS就行。Vue模板则是自定义一套DSL语言，他有自己的一套语法，如v-if v-for。这其实是增加了学习，理解，后期维护成本。这种类型的模版还存一个很大的问题，就是灵活性不足，所以只能添加各种指令或标签来提高灵活性，只要是模板型框架你不可避免要学习一大堆模板语法。当然你可以说vue也支持jsx，我也可以用jsx，但这其实不符合vue开发模式的，而且vue的比较热门的UI库，有的内部实现其实是用了jsx，我只能说：真乱。灵活性的不足最终限制开发者的创造力，在这种情况下，必然会有部分开发者跳出这种模式，寻找新的开发模式，比如React或理念更先进框架。理由二：数据流。React是单向的，这其实非常清晰，视图的改变必须通过setState来触发Vue是双向的，这可能在刚开始接触的时候看起来非常美好，但这种微妙关系真的是个坑，如果我想刷新视图，我其实只能改变数据模型的相关数据，很多时候我非得加个watch或computed来处理，难道用Vue的对这一层概念不觉得啰嗦没吗？这里要提下小程序，它的开发模式其实我也不喜欢，但小程序是因为渲染机制不一样，我接受了，但是使用了setData来明确UI更新入口，我觉得是非常正确的。注：评论指出的双向问题我这里的描述确实不是很准确。我想表达的意思是：数据绑定（数据和视图可以互相影响）。它的体现是：操作数据会直接体现在UI上，这可能在刚开始接触的时候看起来非常美好，但这种微妙关系，会带来一定的心智负担及问题排查。另外社区活跃再知乎看到过一个回答，React开发者都忙着造轮子，我其实是认同这说法的，这并不是说React的社区没有这个轮子，而是React给了你种感觉，我也可以轻松的造出来，并能轻松分享到社区及项目中使用。相反Vue其实给我的感觉就是在于一些状态库，路由库，动画库上都是官方提供了一套，而是他们必须得和Vue有种深层次关联，这注定了普通开发者没办法写的。如果你的项目只是CRUD的功能，用vue jquery angular react其实都无所谓，因为确实都能很轻松满足，但如果你的项目具有较高的灵活性和规模的时候我的推荐是：React。","link":"/2018/09/18/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/Vue%20%E5%92%8C%20React/"},{"title":"业务中台系统的一些想法 [原创]","text":"正直商家一期的契机，商家中心后台迎来大改版的机会，在经历了整个商家中心的重构之后，给我们中台系统建设的思路带来了哪些问题，又该有哪些思考？ 解决方案很多人喜欢讲解决方案，那么什么才是解决方案，电商系统？Sass？Antd？如果站在一个初创期公司的一线前端开发人员的角度来讲，对于内外部中后台系统，可以认为一整套的快速高效、质量可靠的业务满足流程就是一套解决方案。 工程化下面是之前在微博上看到的对前端工程化的理解，其实这里更确切的讲是广义上的前端工程。 什么是前端工程？其实就是面向具体的业务形态，抽象的一套标准化研发过程管理方法。通过规范化的研发全生命周期管理，帮助团队高质高效地保障业务生长。一定规模的前端工程化，少不了数据收集、权限管控、流程管控、规范设计、工具整合等；并非所有的团队都需要实现前端工程化，小规模的组织或个人通过工具提效即可满足基本诉求，复杂的工程管理维护的成本是巨高的，不同业务类型的前端工程设计也会存在差异。前端工程的演进，大致为：工具化-&gt;流程化-&gt;工程化-&gt;平台化，足够体量的规模才需要进入平台化，进入平台化，也意味着统一和一致协同，业务的个性化差异太多，抹平不同团队的差异，阻力很大。一个好的思路是“全控代码、扼制发布”。然后再看一个系统演变的一般的节奏是什么样子？ 我们现在处于哪个阶段其实很明显，被需求绊住了腿、被业务压完了腰的起步阶段，阶段不同，所以核心目标也会不一样。 中台系统对于中台系统，MVVM + UI Library 基本就可以满足90%的业务需求。那么这个阶段我们 要不要交互？ 要不要视觉？ 要不要自研所有的工具？ 要不要做规范输出？ 要不要做基础平台支撑？ 我的理解是不需要，起码是大部分都不需要。以新的商家中心作为例子来说，核心是 Vue + AntD(Vue) ，其他的npm包只是零星的功能点暂且不表。一个中台系统要解决的问题包括： 菜单、路由、权限（为什么将这三者合并到一起来讲，因为在常规的设计上他们是高耦合的）； 网络请求（错误码要做哪些统一封装？接口模块按照页面级还是后端微服务维度？） webpack配置（devServer、拆包优化、打包路径、压缩等等的处理，其实Vue和React现在都倾向于脚手架定制，但还是要关心） Utils（模块划分合理，达成共识，增量添加，不要出现分叉各用各的） 状态管理（做了这么多项目下来，其实真正将状态管理重度使用的场景并不是很多，大多数只是用来做了登录态的保存，这还是结合了本地存储的能力） 公共组件（这是一个存在巨大分歧的地方，像对form表单的封装，做不好最后就会成为项目里最头疼的一块，本身form表单组件设计就复杂，然后你做一层看似提效的抽象，殊不知无形中又加重了开发人员的理解成本） 只要合理的解决了上面所提到这些问题，然后具象后落地为一套模板，无论公司启动多少新的项目，新的系统，PRD给过来，合理的工时评估是可期的，而且开发模式共通，相互之间的技术补位也成为可能（当然业务逻辑复杂的场景补位还是会存在问题）。","link":"/2019/11/01/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%8F%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%20%5B%E5%8E%9F%E5%88%9B%5D/"},{"title":"2020年09月30日","text":"需求理解能力，业务建模能力，流程规范能力是比你看懂点底层框架梗直接高效的点","link":"/2019/06/14/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E9%9A%8F%E7%AC%94/2020%E5%B9%B409%E6%9C%8830%E6%97%A5/"},{"title":"内置对象","text":"1、简介 1.1 概述像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc() 和 free() 。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。 1.2 生命周期不管什么程序语言，内存生命周期基本是一致的： 分配 使用 释放/归还 2、JavaScript 内存分配 2.1 初始化1234567891011121314151617181920212223242526272829// 给数值变量分配内存var n = 123;// 给字符串分配内存var s = &quot;azerty&quot;; // 给对象及其包含的值分配内存var o = { a: 1, b: null};// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, &quot;abra&quot;]; // 给函数（可调用的对象）分配内存function f(a){ return a + 2;}// 函数表达式也能分配一个对象someElement.addEventListener('click', function(){ someElement.style.backgroundColor = 'blue';}, false);// 分配一个 Date 对象var d = new Date(); // 分配一个 DOM 元素var e = document.createElement('div'); 2.2 使用值使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 2.3 释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 3、垃圾回收如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。 3.1 引用垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 3.2 算法 3.2.1 引用计数这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 示例123456789101112131415var o = { a: { b:2 }}; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有var oa = o2.a; // 引用“这个对象”的a属性 // 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = &quot;yo&quot;; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了 // 但是它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 限制：循环引用该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 12345678function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return &quot;azerty&quot;;}f(); 实际例子IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏： 123456var div;window.onload = function(){ div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);}; 在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。 3.2.2 标记清楚这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。限制: 那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。","link":"/2018/08/25/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E9%9A%8F%E7%AC%94/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"ESLint","text":"配置ESLint 暴露出来的所有的可配置项如下： extends 、 plugins 、 parserOptions 、 env 、 globals 、 rules 。 extends继承 plugins插件 processor插件可以提供处理器 处理器可以从其他类型的文件中提取JavaScript代码，然后让ESLint对该JavaScript代码进行处理 或者处理器可以出于某种目的在预处理中转换JavaScript代码。 123456789101112131415{ &quot;plugins&quot;: [&quot;a-plugin&quot;], &quot;overrides&quot;: [ { &quot;files&quot;: [&quot;*.md&quot;], &quot;processor&quot;: &quot;a-plugin/markdown&quot; }, { &quot;files&quot;: [&quot;**/*.md/*.js&quot;], &quot;rules&quot;: { &quot;strict&quot;: &quot;off&quot; } } ]} parserparser ：ESLint 默认指定 Espree 作为解析器，可以通过该选项指定其他的解析器。 123{ &quot;parser&quot;: &quot;esprima&quot;} parserOptionsparserOptions ：默认情况下，ESLint 以 ECMAScript 5语法作为校验标准，可以使用该选项覆盖设置以启用对其他 ECMAScript 语言版本以及对 JSX 等的支持。 1234567891011121314151617181920{ &quot;parserOptions&quot;: { // ECMAScript 版本号 // 3、5、6、7、8、9、10、11 // 2015、2016、2017、2018、2019、2020 &quot;ecmaVersion&quot;: 11, // 脚本类型 // script：一般脚本类型 // module：ECMAScript 模块类型 &quot;sourceType&quot;: &quot;module&quot;, // 额外的语法特性 &quot;ecmaFeatures&quot;: { &quot;globalReturn&quot;: true, // 是否支持全局的 return 语句 &quot;impliedStrict&quot;: true, // 启用全局严格模式（如果ecmaVersion为5或更大） &quot;jsx&quot;: true // 是否支持 jsx 语法 } }} 支持 JSX 语法不等同于支持 React 支持 ES6 语法不等同于支持新的 ES6 全局变量。 对于支持 ES6 语法，设置项为： { &quot;parserOptions&quot;: {&quot;emcaVersion&quot;: 6}} 对于支持 ES6 新的全局对象，设置项为：{ &quot;env&quot;: {&quot;es6&quot;: true}} {&quot;env&quot;: {&quot;es6&quot;: true}} 默认开启 ES6 语法；{ &quot;parserOptions&quot;: {&quot;emcaVersion&quot;: 6} } 不能支持 ES6 新的全局对象； envenv ：指定脚本运行的环境（语言版本、宿主环境等都包含在内），每个环境都附带了一组特定的预定义全局变量。 123456{ &quot;env&quot;: { &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;] }} globalglobal ：可以指定额外的全局变量，比如全局引入了 jQuery。 123456{ &quot;globals&quot;: { &quot;$&quot;: true, &quot;_&quot;: true }} rulesrules ：该配置项指定启用哪些规则以及该规则处于什么错误级别，不指定默认全部关闭。 123456{ &quot;rules&quot;: { &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;], &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;] }} ESLint 规则分为两类： 代码格式规则：比如 max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style… 代码质量规则：比如 no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors… 每条配置项的值可以为： 字符串形式（校验等级） 字符串数组（ [校验等级、校验形式] ） 校验等级分为以下三级： &quot;off&quot; / 0 ：规则关闭； &quot;warn&quot; / 1 ：规则开启，但只抛错不会影响校验进程（exit code = 0）； &quot;error&quot; / 2 ：规则开启，抛错并退出程序（exit code = 1）；","link":"/2018/02/22/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/ESLint/"},{"title":"概述","text":"说明开发人员不同的编码习惯、不同的编辑器、不同的格式化规则，导致了项目协作时的代码风格不统一问题。因此即使业务逻辑没有任何改动的情况下，也可能会因为代码风格的不统一进行了格式化代码之后，造成文件的冲突，而且这种冲突一般很难解决。 关于代码风格的几个核心认知前提列举如下： 代码风格没有绝对的好坏，过多的争论没有意义 为了解决因代码风格不同而造成的冲突问题，因此代码风格很有必要统一 工具语言不同、场景不一样，所使用的工具和工具所对应的配置项也不一样。 Web 开发中，语言大体可分为： HTML（pug、jade、ejs 等模板语法） CSS（LESS、SASS 等预处理语言） JavaScript（不同的 ECMAScript 版本） 常用的组件化开发框架有： React（JSX 语法） Vue（template、script、style） 针对上述所提及到的不同编程语言和开发框架，分别对应的格式化工具为： HTML：htmllint（放弃吧，目标很美好、过程比较痛苦） CSS：Stylelint JavaScript：ESLint 接下来的几章，将分别介绍ESLint、Stylelint 和 Prettier这三个和代码风格统一相关的工具。","link":"/2018/03/08/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/%E6%A6%82%E8%BF%B0/"},{"title":"Git 分支管理规范","text":"1.流程 Action 说明： 从master分支拉取对应的feature和dev分支，分支名：feature_需求编号，版本号：master版本号_时间戳_SNAPSHOT 当master代码发生变更后，需merge到仍在开发测试中的feature分支 从master分支拉取对应的hotfix分支，分支名：hotfix_BUG_11【hotfix_XG_99】，版本号：master版本号中z+1【如：master分支版本号为1.1.5，则hotfix分支版本号为1.1.6】 feature分支部分功能或全部功能已开发联调完成提测 feature分支在测试过程中修复BUG的过程 当dev或hotfix分支对应的需求测试完成后准备进入预发布阶段时，从此dev_XG_26或hotfix拉取对应的release_XG_26分支并修改版本号，发布到UAT环境进行回归测试 release分支在UAT回归测试过程中发现BUG进行修复，或者有已评估通过的紧急需求需要进行开发的过程 UAT回归验证通过后发布生产 提交merge request并找对应的模块负责人Code Review 已上线的分支合并到master分支并打Tag 待优化的点： 当Jira 需求状态变更为_开始开发_时，就自动执行1⃣️操作。 当Jira 上需要紧急发布的需求或紧急修复的BUG状态变更为_开始开发_时，就执行3⃣️操作。 当feature分支对应的需求在Jira上状态变更为_提测_时，就执行9⃣️操作。2.分支说明master 分支【线上分支】 master 分支时常保持着软件可以正常运行的状态。由于要维护这一状态，所以不允许开发者直接对master 分支的代码进行修改和提交。其他分支的开发工作进展到可以发布的程度后，将会与master分支进行合并，并且这一合并只在发布成品时进行。发布时将会附加版本编号的Git标签。 feature分支【功能分支】 feature 分支以master分支为起点，是开发者直接进行功能开发的分支。开发流程： 从master分支创建feature分支，分支名：feature_需求编号，版本号：master版本号_时间戳_SNAPSHOT 从feature分支中实现目标功能 通过GitLab 向dev分支发起merge request 接受其他开发者审核后，将merge request合并至dev分支 与dev分支合并后，开发人员发送提测邮件 测试人员将此dev分支发布至测试环境，开始测试 注意：每天早上将最新的master代码合并到feature分支时，记得一定要先git checkout master、git pull origin master，保证master分支处于最新状态。 dev分支【提测分支】 dev分支是提测分支，dev与对应的feature分支需同时从master中拉取出来，待feature分支功能开发完成后，将feature分支代码合并到dev分支，开始提测。与master 分支一样，这个分支也不允许开发者直接进行修改和提交。在多个版本需求并行测试的过程中，此分支会存在多个。 release分支【发布分支】 创建 release分支 ，在这个分支，我们只处理与发布前准备相关的提交，比如变更版本号。如果已经部署到UAT后测试出bug，相关修正也要提交到这个分支。注意：该分支绝对不能包含功能变更等重大修正。这一阶段的提交数应该限制到最低。 hotfix分支【紧急修复分支】 hotfix是从master或release分支上拉取出来的分支，主要用于线上紧急需求开发或紧急问题修复或预发环境的BUG修复。hotfix开发完成后，需要向release提交merge request。下述情况需要创建 hotfix 分支： 线上发生漏洞需要及早修复 紧急需求无法等到下一个版本一起发布 预发环境发现的BUG修复 3. 标签和发布 release分支每次发布完成后将代码合并到master分支，再从master分支上创建当前版本的tag，填写此版本相关发布内容。 4. 版本号分配规则 版本号的分配规则 x.y.z x: 在重大功能变更，或者版本不向下兼容+1，此时y、z归零 y: 在添加新功能或者删除已有功能+1 此时z归零 z: 紧急发布为奇数，日常周迭代为偶数","link":"/2018/05/10/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/"},{"title":"中后台交互规范","text":"** ** ** 搜索 1、搜索项超过两行的添加折叠展开便捷选项（建议） 可参考 Antd 2、搜索项以 form-item 默认自适应排布，时间、省市区等不规则项尽量向后排布 原型稿不规范的，以此规则为准 列表 | 1、数据项根据创建时间降序排序 | 后端场景，特殊场景以产品PRD为准 || | 2、分页sizes：[20, 50, 100]，默认20 | || | 3、初始化不搜索的列表缺省页统一，Notification通知提醒 | 文案“请输入搜索条件后查询”； || | 4、分页器始终悬浮在顶部右上方，自适应，依次判断操作栏或标签栏是否有足够位置； | || | 5、列表字段的时间格式：YYYY-MM-DD hh:mm:ss； | || | 6、搜索约束： 关键词不区分大小写、 搜索关键词默认首尾去空格 编号搜索是精准搜索 文本搜索是模糊搜索| 空格问题：筛选条件必须处理、表单创建提交时对出错频次较高项做处理 || | 7、非删除操作按钮均已 primary 类型为准； | || | 8、列表型页面，筛选栏只放置重置、搜索操作，其余按钮均放置在表格头部； | || | 9、列表操作栏归并为一列，按钮类型 text ，fixed右侧； | || | 10、列表加载需添加loading状态 | || | 11、空值字段以中划线 “-” 占位 | || 操作类 | 1、特定操作提交前需经过确认 任何删除操作，文案“您确定要删除吗？”； 列表栏高风险类操作 表头操作：绑定/解绑、停用/启用、审核/驳回、解冻/冻结、关闭/开启、重置、复制、上架/下架、失效/生效/作废/恢复（尤其批量操作）| 绑定/解绑、停用/启用、审核/驳回、解冻/冻结、关闭/开启、重置、复制、上架/下架、失效/生效/作废/恢复（高风险类，需要弹窗确认） 查看详情、编辑等（非风险类）|| | 2、配色： 高危操作红色 警告提示黄色 正常操作蓝色| 操作类型同上 || | 3、涉及页面跳转的按钮，以 router-link 组件承载 | 目的是为满足既可以本页面打开，又可通过Ctrol（Command） + 点击 新标签打开 || 文案类 | 1、通用操作名称统一 | 添加、删除、编辑、查看、通知、执行、导出、导入、审核、上架、下架、备注、置顶（其他待补充） || | 2、平台会员账户 手机号 会员号| 无会员账户、会员~~~~Code一说 || 表单 | 1、右对齐，添加中文冒号做对齐标识； | |","link":"/2018/06/01/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/%E4%B8%AD%E5%90%8E%E5%8F%B0%E4%BA%A4%E4%BA%92%E8%A7%84%E8%8C%83/"},{"title":"代码命名规范","text":"为什么要强调代码命名规范？ 增强代码的可读性 增强代码的可维护性 正由于上述两个作用，从而使得开发效率 &amp; 维护效率得到大幅度的提高。 命名规则： camelCase(驼峰式)：videoExampleComponent PascalCase(大驼峰式)：VideoExampleComponent kebab-case(烤串式)：video-example-component Vue驼峰式： JavaScript 变量 JavaScript 函数 PascalCase： JavaScript 类 组件文件（VideoList.vue，操作系统不同、大小写敏感程度不同） kebab-case： HTML（大小写不敏感） React 组件，或者类名，首字母全部大写，遵守驼峰命名法。eg: LoginPage 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式，即首字母小写。 eg: passwordNum / getMessage() / inputPassword 监听事件的事件名 命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例: MAX_CAT_COUNT 反例: MAX_COUNT 4.文件夹命名统一小写。正例: components // 存放一些组件 资源图片名字不允许使用中文,全部小写,单词间用下划线隔开。正例: home_back.png // 图片名 页面组件,属性换行：组件属性调用多个时,需要进行换行处理 Vue","link":"/2018/06/18/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"},{"title":"魔鬼数字规范","text":"魔鬼数字的定义：在代码中没有具体含义的数字、字符串。魔鬼数字主要影响了代码可读性，读者看到的数字无法理解其含义，从而难以理解程序的意图。当程序中出现的魔鬼数字过多时，代码的可维护性将会急剧下降，代码变得难以修改，并容易引入错误。 例如： 1234567if (status === 1) { // code} else if (status === 2) { // code} else { // code} 修改后：const ACTIVITY_STATUS_NOT_EXIST = 0 // 活动不存在 const ACTIVITY_STATUS_START = 1 // 活动已开始 const ACTIVITY_STATUS_END = 2 // 活动已结束 1234567if (status === ACTIVITY_STATUS_START) { // code} else if (status === ACTIVITY_STATUS_END) { // code} else { // code} 通过设置常量，并已适当的名称和注释标明，提高代码可读性，名称命名规范为全大写，单词之间使用’_’分割或者将这些常量统一放在某个对象中： 12345678const ENUMSTATUS = { // 注释 ACTIVITY_STATUS_NOT_EXIST: 0, // 注释 ACTIVITY_STATUS_START: 1, // 注释 ACTIVITY_STATUS_END: 2}","link":"/2018/06/28/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E8%A7%84%E8%8C%83/%E9%AD%94%E9%AC%BC%E6%95%B0%E5%AD%97%E8%A7%84%E8%8C%83/"},{"title":"H5视频播放踩坑记录","text":"场景某H5页面，页面由图片组成，其中某张图片点击后将全屏播放视频(其中视频定位到非可视区域)。视频播放组件采用的第三方库video-react 问题app webview下安卓视频无法播放、ios需要点击两次才播放，微信环境下全屏播放问题 1.居然是样式首先测试的时候pc浏览器以及手机浏览器环境下测试都是ok，所以初步判断问题出在webview上，通过debug，打印点击事件以及相关视频的信息，发现都是正常的并且没有发生报错情况。后猜测是否跟全屏播放有关，将视频取消定位后正常展示，此时播放正常。这时对比前面异常情况发现有个变量定位，遂找到对应样式，发现其中某个属性**z-index**: -1，去掉后一切正常了，Android和iOS均正常播放。至于为什么会受这个属性影响，暂不清楚。 2.关于全屏自动播放视频点击后全屏播放，取消全屏播放后视频暂停(因为视频不在可视区域，没有对应的操作可点)。组件提供了播放以及切换全屏方法，但是并没有切换全屏后的回调事件，好在组件额外提供了subscribeToStateChange方法，可以监听组件的所有状态，一波操作后： 1234567891011121314151617181920212223242526imgClick (item) { const v = this.player // 视频组件实例 v.toggleFullscreen() // 切换全屏 this.showVideoAndPlay = true}/** 监听视频信息变化 */handleStateChange(state) { const v = this.player.player if (!state.isFullscreen) { v.pause() this.showVideoAndPlay = false return } if (state.isFullscreen &amp;&amp; this.showVideoAndPlay){ v.play() /** 这里要重置 不然会无限播放暂停循环*/ this.showVideoAndPlay = false return } if (state.paused) { v.pause() }}componentDidMount() { this.player.subscribeToStateChange(this.handleStateChange.bind(this));} 看到app表现良好，暗暗点了点头，表面很冷静，心里美滋滋。但是，打脸这事，会迟到但是不会缺席，很快测试告知微信环境下播放有问题… 微信视频播放 微信浏览器的视频播放采用了自带的播放器，所以如果按照前面那个方式，点击打开后出现的是个黑屏,需要再次点击播放才能正常播放。经过一波调试，点击播放代码修改如下: 12345imgClick (item) { const v = this.player // 视频组件实例 v.play() v.toggleFullscreen() // 切换全屏 } 但是又发现安卓跟ios表现又是不一样 ios下正常，安卓下视频播放变为横屏，且没有自动播放，在点击播放然后退出全屏或者直接退出全屏后再次重新播放，正常竖屏并且自动播放。 同时，在app 安卓环境下，全屏后无法自动播放。 上诉两个问题在调整播放跟切换全屏两个方法后各自解决，于是代码修改为：1234567891011imgClick (item) { const v = this.player // 全屏跟播放顺序在app环境跟微信下是两个结果 ios默认播放全屏 if (bridge.isInApp()) { !this.$os.ios &amp;&amp; v.toggleFullscreen() // 切换全屏 v.play() } else { v.play() !this.$os.ios &amp;&amp; v.toggleFullscreen() // 切换全屏 } } 其中对全屏方法做了环境判断是因为 iso 下默认播放全屏至此，app与微信环境下全屏展示基本一致，只剩下安卓微信环境下自动播放问题。这个问题最终采用延时方案解决，但并不是完美解决，还是会存在偶发的不能自动播放的情况。具体什么原因全靠猜，其中机制并不是特别清楚，有待后续研究。所以最后代码修改如下： 1234567891011imgClick (item) { const v = this.player // 全屏跟播放顺序在app环境跟微信下是两个结果 ios默认播放全屏 if (bridge.isInApp()) { !this.$os.ios &amp;&amp; v.toggleFullscreen() // 切换全屏 v.play() } else { v.play() !this.$os.ios &amp;&amp; setTimeout(() =&gt; {v.toggleFullscreen()},500) // 切换全屏 } } 补充1ios 微信环境下视频初始化黑屏解决方案： // react ref … ref={player =&gt; { this.player = player // 微信sdk this.$JSBridge({ success: () =&gt; { this.player.pause(); } }, &quot;getNetworkType&quot;); }} … 1","link":"/2019/09/16/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/H5%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"微信不支持检测 HTML History PushState 变化的问题","text":"问题描述如果你在微信里面浏览一个网站，这个网站使用了 HTML History 的 PushState 来更改 URL 的话（SPA应用中的browser history模式），微信会无视这个 URL 的变化，于是导致你在分享这个 URL 的时候，发现始终是这个网站的最初的 URL，而不是最新的 URL。比如：访问A页面，然后进入B页面，分享到外部的链接依然是A页面的URL。 影响 分享验签时的targUrl无效 回退空白页 支付目录验证不通过解决方案 尝试：默认路由监听组件变更，通过以下形式： replaceState形式强制变更当前state location重定向自身位置 location重定向自身位置+时间戳 以上方案无效。 最终方案：react-router history跳转改为location.href重定向形式，导致状态管理可能会受限，多余资源请求。 React-Router并不是Router的问题，而是微信浏览器的功能缺陷（暂时理解）。 相关问题：IOS WeChat share address is not the current page routing addressapplication can’t rerendering view when application back from the third page","link":"/2019/09/22/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/%E5%BE%AE%E4%BF%A1%E4%B8%8D%E6%94%AF%E6%8C%81%E6%A3%80%E6%B5%8B%20HTML%20History%20PushState%20%E5%8F%98%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"内置对象","text":"1、JSON123456789101112131415161718/** * 构造器 */// 无/** * 静态方法 */JSON.parse(text[, reviver])JSON.stringify(value[,replacer[,space]])/** * 静态属性 */// 无 2、Math123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 构造器 */// 无/** * 静态方法 */// 三角函数Math.cos(x)Math.acos(x)Math.sin(x)Math.asin(x)Math.tan(x)Math.atan(x)Math.atan2(y,x)// 双曲函数Math.sinh(x)Math.asinh(x)Math.cosh(x)Math.acosh(x)Math.tanh(x)Math.atanh(x)// 对数函数Math.log(x)Math.log2(x)Math.log1p(x)Math.log10(x)// 数学计算Math.abs(x)Math.pow(x,y)Math.sqrt(x)Math.cbrt(x)Math.exp(x)Math.expm1(x)Math.hypot(x[,y[,...]]])Math.imul(x,y)// 功能函数Math.floor(x)Math.ceil(x)Math.max([x,[y,...]]])Math.min([x,[y,...]]])Math.random(x)Math.round(x)Math.trunc(x)Math.sign(x)Math.fround(x)Math.clz32(x)/** * 静态属性 */Math.PIMath.EMath.LN2Math.LN10Math.LOG2EMath.LOG10EMath.SQRT1_2Math.SQRT1_2 3、Boolean1234567891011121314151617181920212223242526272829303132333435/** * 构造器 */// 一、类型转换// 1. 假值Boolean（）Boolean(0)Boolean(-0)Boolean(null)Boolean(false)Boolean(NaN)Boolean(undefined)Boolean(“”)// 2. 真值// 除去所有假值的情况，包括空数组、空对象或者&quot;false&quot;等// 二、对象构造new Boolean(false) // 对象构造/** * 静态方法 */// 无/** * 静态属性 */Boolean.prototype // Boolean 类型Boolean.prototype.constructorBoolean.prototype.toString()Boolean.prototype.valueOf() 4、Number123456789101112131415161718192021222324252627282930313233343536373839/** * 构造器 */Number(’123‘ ） // 类型转换new Number(123) // 对象构造/** * 静态方法 */Number.isNaN（）Number.isFinite（）Number.isInteger（）Number.isSafeInteger（）Number.parseFloat（）Number.parseInt（）/** * 静态属性 */Number.EPSILONNumber.MAX_SAFE_INTEGERNumber.MIN_SAFE_INTEGERNumber.MAX_VALUENumber.MIN_VALUENumber.NaNNumber.NEGATIVE_INFINITYNumber.POSITIVE_INFINITYNumber.prototype // Number 类型Number.prototype.constructorNumber.prototype.toExponential（）Number.prototype.toFixed（）Number.prototype.toLocaleString（）Number.prototype.toPrecision（）Number.prototype.toString（）Number.prototype.valueOf（） 5、Error123456789101112131415161718192021/** * 构造器 */Error() // 等铜于 new Error()/** * 静态方法 */// 无/** * 静态属性 */Error.prototype.constructorError.prototype.messageError.prototype.nameError.prototype.toString（） 其他错误类型对象： EvalError RangeError ReferenceError SyntaxError TypeError URIError 6、RegExp12345678910111213141516171819202122232425262728293031323334353637383940/** * 构造器 */RegExp() // 等铜于 new RegExp()/** * 静态方法 */// 无/** * 静态属性 */RegExp.RegExp[Symbol.species]RegExp.lastIndexRegExp.prototype //ObjectRegExp.prototype.constructorRegExp.prototype.globalRegExp.prototype.ignoreCaseRegExp.prototype.multipleRegExp.prototype.sourceRegExp.prototype.flagsRegExp.prototype.dotAllRegExp.prototype.stickyRegExp.prototype.unicodeRegExp.prototype.lastIndex // 在全局匹配的正则表达式上，exec、test 会改变此属性RegExp.prototype.exec（）RegExp.prototype.test（）RegExp.prototype.[Symbol.match]（）RegExp.prototype.[Symbol.matchAll]（）RegExp.prototype.[Symbol.replace]（）RegExp.prototype.[Symbol.search]（）RegExp.prototype.[Symbol.split]（）RegExp.prototype.toString（） 7、Date123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 一、构造器 */// 结果为字符串Date() // 表示实例化时刻的日期和时间，不接受参数// 结果为对象new Date() // 表示实例化时刻的日期和时间new Date(value) // 入参表示自 1970 年 1 月 1 日 00:00:00以来的毫秒数new Date(dateString) // dateString 为表示日期的字符串new Date（year,monthIndex,[day[,hours[,minutes[,seconds[,milliseconds]]]]]） // 至少提供年份与月份/** * 二、静态方法 */Date.now（） // 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数Date.parse() // 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00所经过的毫秒数Date.UTC() // 接受和构造函数最长形式的参数相同的参数，并返回从 1970-1-1 00:00:00 UTC 开始所经过的毫秒数/** * 三、静态属性 */Date.length // 继承自 Function 的属性，为7，即该构造函数可接受的参数个数Date.prototype // ObjectDate.prototype.constructor// GetDate.prototype.getFullYear（）Date.prototype.getUTCFullYear（）Date.prototype.getMonth（）Date.prototype.getUTCMonth（）Date.prototype.getDate（）Date.prototype.getUTCDate（）Date.prototype.getDay（）Date.prototype.getUTCDay（）Date.prototype.getHours（）Date.prototype.getUTCHours（）Date.prototype.getMinutes（）Date.prototype.getUTCMinutes（）Date.prototype.getSeconds（）Date.prototype.getUTCSeconds（）Date.prototype.getMilliseconds（）Date.prototype.getUTCMilliseconds（）// SetDate.prototype.setFullYear（）Date.prototype.setUTCFullYear（）Date.prototype.setMonth（）Date.prototype.setUTCMonth（）Date.prototype.setDate（）Date.prototype.setUTCDate（）Date.prototype.setHours（）Date.prototype.setUTCHours（）Date.prototype.setMinutes（）Date.prototype.setUTCMinutes（）Date.prototype.setSeconds（）Date.prototype.setUTCSeconds（）Date.prototype.setMilliseconds（）Date.prototype.setUTCMlliseconds（）Date.prototype.setTime（）// OtherDate.prototype.toDateString（）Date.prototype.toISOString（）Date.prototype.toJSON（）Date.prototype.toLocaleDateString（）Date.prototype.toLcaleString（）Date.prototype.toLocaleString（）Date.prototype.toLocaleTimeString（）Date.prototype.toString（）Date.prototype.toTimeSting（）Date.prototype.toUTCString（）Date.prototype.valueOf（） 8、String1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 一、构造器 */String(123) // 类型转换new String(123) // 对象构造/** * 二、静态方法 */String.fromCharCode()// 通过一串 Unicode 创建字符串String.fromCodePoint() // 通过一串 码点 创建字符串/** * 三、静态属性 */String.prototype // objectString.prototype.constructorString.prototype.length // 返回字符串长度// 查找索引位置字符String.prototype.N // 'abcd'[3] =&gt; dString.prototype.charAt()// 返回指定索引位置的字符String.prototype.charCodeAt() // 返回指定索引位置的字符的 Unicode 值String.prototype.codePointAt() // 返回使用 UTF-16 编码的给定位置的值的非负整数// 子串搜索String.prototype.includes() // 判断一个字符串里是否包含其他字符串String.prototype.indexOf()String.prototype.lastIndexOf()String.prototype.match()String.prototype.search() // 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标String.prototype.startsWith() // 判断当前字符串是否以另外一个给定的子字符串开头String.prototype.endsWith() // 判断当前字符串是否以另外一个给定的子字符串结尾// 片段截取String.prototype.slice()String.prototype.substring()String.prototype.substr()// 补位String.prototype.padStart()String.prototype.padEnd()// 去空格String.prototype.trim()String.prototype.trimStart()| trimLeft()String.prototype.trimEnd()| trimRight()// 大小写转换String.prototype.toLocaleLowerCase()String.prototype.toLowerCase()String.prototype.toLocaleUpperCase()String.prototype.toUpperCase()String.prototype.concat() // 连接String.prototype.split() // 拆分String.prototype.repeat() // 重复String.prototype.replace() // 替换String.prototype.localeCompare()String.prototype.normalize()String.prototype.toString()String.prototype.valueOf()String.prototype.String.prototype[@@iterator]() 9、Array123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 一、构造器 */new Array（） // 空数组：[]new Array（length） //（有且仅有一个参数，并且为 Number类型）：构造一个长度为入参、每一项为 undefined 的数组new Array（element0, element1[, ...[, elementN]]）/** * 二、静态方法 */Array.from(arrayLike，mapFn，thisArg) // 将类数组、可迭代对象创建为一个新的、浅拷贝的数组实例Array.of // 弥补 Array 构造函数入参为单个数字时的迷惑行为Array.isArray/** * 三、静态属性 */Array.prototype // ArrayArray.prototype.constructorArray.prototype.length// 变异方法Array.prototype.copyWithin(target，start，end) // 截取 start 到 end 区间的元素，复制到 target Array.prototype.fill(value，?start，?end) // 用 value 替换 start 到 end 区间的值Array.prototype.reverse()Array.prototype.sort(fn)Array.prototype.pop() // 删除末尾一个元素，并返回该元素的值Array.prototype.push(element1，...，elementN)// 向数组末尾添加新的元素Array.prototype.shift()// 删除第一个元素，并返回该元素的值Array.prototype.unshift(element1，...，elementN)// 向数组开头添加新的元素Array.prototype.splice(start，?deleteCount，item1，...，itemN)// 删除或替换现有元素，并且可以追加元素到当前删除位置 // 非变异方法Array.prototype.concat()// 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。Array.prototype.includes()// 判断一个数组是否包含一个指定的值Array.prototype.join(?separator)// 返回数组所有元素以分隔符分割后的字符串Array.prototype.slice(start，end)// 返回包含某个区间内元素的新数组Array.prototype.toString()Array.prototype.toLocaleString()Array.prototype.indexOf(searchElement，?fromIndex)Array.prototype.lastIndexOf(searchElement，?fromIndex)Array.prototype.forEach// 迭代器Array.prototype.entries() // 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。Array.prototype.keys() // 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。Array.prototype.values()| [Symbol.iterator()] // 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。// 条件检测Array.prototype.every() // 检测数组中是否每一个元素都满足测试函数Array.prototype.some()// 检测数组中是否至少有一个元素满足测试函数// 迭代修改Array.prototype.filter()// 将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。Array.prototype.map()// 返回一个由回调函数的返回值组成的新数组。// 扁平化Array.prototype.flat(depth = 1) // 数组扁平化Array.prototype.flatMap(cb(current，index，array)) // 还不太会用// 查找Array.prototype.find()Array.prototype.findIndex()// 从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。Array.prototype.reduce(cb(accumulator，item，index，sourceArray)，initialValue) // 从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。Array.prototype.reduceRight(cb(accumulator，item，index，sourceArray)，initialValue) 10、Function12345678910111213141516171819202122232425262728/** * 一、构造器 */new Function([arg1[, arg2[, ...argN]],] functionBody) // const sum = new Function('a', 'b', 'return a + b');Function([arg1[, arg2[, ...argN]],] functionBody)// 同 new Function（）/** * 二、静态方法 */// 无/** * 三、静态属性 */Function.arguments // 被全局变量 arguments 替代Function.caller // 获取调用函数的具体对象Function.length // 获取函数的接收参数个数Function.name // 'Function'Function.prototype // 'function'Function.prototype // 'function'Function.prototype.apply(thisArg，?[argsArray])Function.prototype.call(thisArg，?arg1，?arg2，...)Function.prototype.bind(thisArg，?arg1，?arg2，...)Function.prototype.isGenerator()Function.prototype.toString() 11、Object1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 一、构造器 */// 1: 如果给定值是 null 或 undefined，将会创建并返回一个空对象// 2: 如果传进去的是一个基本类型的值，则会构造其包装类型的对象// 3: 如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址new Object（[value]）Object（[value]）// 同 new Object（） /** * 二、静态方法 */Object.is(value1,value2)// 判断两者是否相等// 创建对象Object.assign（target，...source）// 复制对象Object.create（proto，?propertiesObject）// 使用现有对象作为原型对象来创建一个新对象// 原型Object.setPrototypeOf（obj，prototype）// 设置一个指定的对象的原型Object.getPrototypeOf（obj）// 返回指定对象的原型对象。// 属性遍历Object.keys（obj）// 返回一个由一个给定对象的自身可枚举属性组成的数组Object.values（obj）// 返回给定对象自身可枚举值的数组。Object.entries（obj）// 返回给定对象自身可枚举属性的键值对数组Object.preventExtensions（obj）// 防止对象的任何扩展Object.isExtensible（obj）// 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）Object.freeze（obj）// 冻结一个对象Object.isFrozen（obj）// 判断对象是否已经冻结。Object.seal（obj）// 防止其他代码删除对象的属性。Object.isSealed（obj）// 判断一个对象是否被密封。Object.defineProperty（obj，prop，descriptor）// 给对象添加/修改一个属性并指定该属性的配置Object.defineProperties（obj，props）// 给对象添加多个属性并分别指定它们的配置。Object.getOwnPropertyDescriptor（obj）// 返回指定对象上的一个自有属性对应的描述符Object.getOwnPropertyNames（obj）// 返回一个由指定对象的所有自身属性的属性名称组成的数组Object.getOwnPropertySymbols（obj）// 返回一个给定对象自身的所有 Symbol 属性的数组。/** * 三、静态属性 */Object.prototype // 'object'Object.prototype.constructorObject.prototype.hasOwnProperty（）// 判断属性是否存在且存在于自身Object.prototype.isPrototypeOf（）// 检查一个对象是否存在于另一个对象的原型链上Object.prototype.propertyIsEnumerable（）// 判断指定属性是否可枚举Object.prototype.toString（）Object.prototype.toLocaleString（）// 同 toStringObject.prototype.valueOf（）constructorconstructorconstructorObject.prototype.apply(thisArg，?[argsArray])Function.prototype.call(thisArg，?arg1，?arg2，...)Function.prototype.bind(thisArg，?arg1，?arg2，...)Function.prototype.isGenerator()Function.prototype.toString() 12、Set123456789101112131415161718/** * 一、构造器 */new Set（[iterable]）/** * 二、静态属性 */Set.prototypeSet.prototype.constructorSet.prototype.sizeSet.prototype.add（value）Set.prototype.delete（value）Set.prototype.has（value）Set.prototype.clear（）Set.prototype.entries（）Set.prototype.keys（）Set.prototype.values（） 13、WeakSet12345678910111213/** * 一、构造器 */new WeakSet（[iterable]）/** * 二、静态属性 */Set.prototypeSet.prototype.constructorSet.prototype.add（value）Set.prototype.delete（value）Set.prototype.has（value） 14、Map1234567891011121314151617181920/** * 一、构造器 */new Map（[iterable]）/** * 二、静态属性 */Map.lengthMap.prototypeMap.prototype.constructorMap.prototype.set（key，value）Map.prototype.get（key）Map.prototype.delete（key）Map.prototype.clear（）Map.prototype.has（key）Map.prototype.entries（）Map.prototype.keys（）Map.prototype.values（）Map.prototype.forEach（cb，thisArg） 15、WeakMap123456789101112131415/** * 一、构造器 */new WeakMap（[iterable]）/** * 二、静态属性 */WeakMap.lengthWeakMap.prototypeWeakMap.prototype.constructorWeakMap.prototype.get（key）WeakMap.prototype.has（key）WeakMap.prototype.set（key，value）","link":"/2018/01/07/JavaScript/Feature/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"规范","slug":"规范","link":"/tags/%E8%A7%84%E8%8C%83/"},{"name":"前端-杂谈","slug":"前端-杂谈","link":"/tags/%E5%89%8D%E7%AB%AF-%E6%9D%82%E8%B0%88/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"代码风格","slug":"代码风格","link":"/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"name":"问题踩坑","slug":"问题踩坑","link":"/tags/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"所思所想","slug":"所思所想","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"},{"name":"属性笔记","slug":"CSS/属性笔记","link":"/categories/CSS/%E5%B1%9E%E6%80%A7%E7%AC%94%E8%AE%B0/"},{"name":"知识点","slug":"CSS/知识点","link":"/categories/CSS/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"预处理语言","slug":"CSS/预处理语言","link":"/categories/CSS/%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80/"},{"name":"ES6","slug":"JavaScript/ES6","link":"/categories/JavaScript/ES6/"},{"name":"Feature","slug":"JavaScript/Feature","link":"/categories/JavaScript/Feature/"},{"name":"CLI","slug":"Vue/CLI","link":"/categories/Vue/CLI/"},{"name":"Feature","slug":"Vue/Feature","link":"/categories/Vue/Feature/"},{"name":"语义化版本","slug":"所思所想/语义化版本","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC/"},{"name":"灵感文章","slug":"所思所想/灵感文章","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E7%81%B5%E6%84%9F%E6%96%87%E7%AB%A0/"},{"name":"随笔","slug":"所思所想/随笔","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E9%9A%8F%E7%AC%94/"},{"name":"方案沉淀","slug":"所思所想/方案沉淀","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/"},{"name":"规范","slug":"所思所想/规范","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E8%A7%84%E8%8C%83/"},{"name":"代码风格","slug":"所思所想/方案沉淀/代码风格","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"},{"name":"问题踩坑","slug":"所思所想/方案沉淀/问题踩坑","link":"/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/%E6%96%B9%E6%A1%88%E6%B2%89%E6%B7%80/%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/"}]}